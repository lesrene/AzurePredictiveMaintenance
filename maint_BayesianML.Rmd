---
title: "maint_BayesianML"
output:
  html_document: default
  pdf_document: default
date: "2025-12-03"
---

```{r}
library(dplyr)
library(tidyr)
library(data.table)
library(lubridate)
library(survival)
library(brms)
```

```{r}
errors      <- read.csv("PdM_errors.csv")
failures    <- read.csv("PdM_failures.csv")
machines    <- read.csv("PdM_machines.csv")
maintenance <- read.csv("PdM_maint.csv")
telemetry   <- read.csv("PdM_telemetry.csv")
```

```{r}
errors$count <- 1

error_features <- errors %>%
  group_by(machineID, errorID) %>%
  summarise(count = sum(count), .groups = "drop") %>%
  pivot_wider(
    names_from  = errorID,
    values_from = count,
    values_fill = 0
  )

head(error_features)
```

```{r}
# telemetry aggregation
telemetry_agg <- telemetry %>%
  group_by(machineID) %>%
  summarise(
    volt      = mean(volt, na.rm = TRUE),
    rotate    = mean(rotate, na.rm = TRUE),
    pressure  = mean(pressure, na.rm = TRUE),
    vibration = mean(vibration, na.rm = TRUE),
    .groups   = "drop"
  )

head(telemetry_agg)
```

```{r}
machine_features <- machines %>%
  left_join(error_features, by = "machineID") %>%
  left_join(telemetry_agg,   by = "machineID")

# ensure model is factor
machine_features$model <- as.factor(machine_features$model)

# R equivalent of pd.get_dummies(machine_features, columns=["model"], drop_first=False)
machine_features <- fastDummies::dummy_cols(
  machine_features,
  select_columns          = "model",
  remove_selected_columns = FALSE,  # keep original 'model' column
  remove_first_dummy      = FALSE   # keep all model dummies
)

head(machine_features)
```

```{r}
maintenance$total_maint_count <- 1
maintenance$datetime <- as.POSIXct(maintenance$datetime)

# counts of total times each component in each machine got maintained
maint_counts <- maintenance %>%
  group_by(machineID, comp) %>%
  summarise(total_maint_count = sum(total_maint_count), .groups = "drop")
```

```{r}
# recency
CURRENT_DATE <- max(maintenance$datetime)

recency_dates <- maintenance %>%
  group_by(machineID, comp) %>%
  summarise(last_maintenance_date = max(datetime), .groups = "drop") %>%
  mutate(
    how_recent = as.numeric(difftime(CURRENT_DATE, last_maintenance_date, units = "days"))
  )

# final component_features
component_features <- maint_counts %>%
  inner_join(recency_dates %>% select(-last_maintenance_date),
               by = c("machineID", "comp"))

head(component_features)
```

```{r}
component_features_df <- component_features %>%
  rename(
    Maint_Count      = total_maint_count,
    Time_Since_Maint = how_recent
  ) %>%
  left_join(machine_features, by = "machineID")

head(component_features_df)
```


```{r}
# makes sure they are datetime objects
failures$datetime    <- as.POSIXct(failures$datetime)
maintenance$datetime <- as.POSIXct(maintenance$datetime)

# combine failures + maintenance tables
# treat failures as 1 (what we're looking for) and maintenance as 0 (reset the clock)
all_events <- bind_rows(
  failures %>%
    transmute(
      machineID,
      comp = failure,
      datetime,
      Event_Status = 1L   # failure = event
    ),
  maintenance %>%
    transmute(
      machineID,
      comp,
      datetime,
      Event_Status = 0L   # maintenance = censored
    )
) %>%
  arrange(machineID, comp, datetime)
```

```{r}
survival_data_base <- all_events %>%
  group_by(machineID, comp) %>%
  arrange(datetime, .by_group = TRUE) %>%
  mutate(
    start_time = lag(datetime),
    T_End      = as.numeric(difftime(datetime, start_time, units = "hours"))
  ) %>%
  ungroup() %>%
  filter(!is.na(T_End), T_End > 0)

survival_data_base
```

```{r}
telemetry$datetime <- as.POSIXct(telemetry$datetime)
survival_data <- copy(survival_data_base)
setDT(survival_data)
setDT(telemetry)

survival_data_base2 <- telemetry[
  survival_data, 
  on = .(machineID, datetime > start_time, datetime <= datetime)
][,
  .(avg_volt_interval = mean(volt, na.rm = TRUE),
    avg_rotate_interval = mean(rotate, na.rm = TRUE),
    avg_pressure_interval = mean(pressure, na.rm = TRUE),
    avg_vibration_interval = mean(vibration, na.rm = TRUE)),
  by = .(machineID, comp, Event_Status, datetime, T_End)
]
survival_data_base2
```

```{r}
survival_data_final <- survival_data_base2 %>%
  select(-datetime) %>%
  left_join(
    component_features_df,
    by = c("machineID", "comp")
  ) %>%
  mutate(
    Event_Status = as.integer(Event_Status) 
  )
survival_data_final
```
```{r}
glimpse(survival_data_final)
```

```{r}
# Event_Status: 1 = failure (event), 0 = censored
# brms expects censored = 1, event = 0 inside cens()
# so we pass cens(1 - Event_Status)

model_formula_aligned <- bf(
  T_End | cens(1 - Event_Status) ~ 
    age +
    avg_volt_interval + avg_rotate_interval + avg_pressure_interval + avg_vibration_interval +
    Maint_Count +
    Time_Since_Maint
)

set.seed(42)

bayes_surv_brms <- brm(
  formula = model_formula_aligned,
  family  = brmsfamily("cox"),
  data    = survival_data_final,
  prior   = prior(normal(0, 0.5), class = "b"),
  chains  = 4,
  iter    = 2000,
  cores   = 4
)

summary(bayes_surv_brms)
```
```{r}
# model accuracy: Concordance Index (C-index)
library(survival)

# posterior linear predictor (log-hazard) for each row in survival_data_final
lp_draws <- posterior_linpred(
  bayes_surv_brms,
  newdata   = survival_data_final,
  transform = FALSE   # keep on log-hazard scale
)

# posterior mean risk score per observation
lp_mean <- colMeans(lp_draws)

# concordance between observed survival times and predicted risk scores
c_index_result <- concordance(
  Surv(survival_data_final$T_End, survival_data_final$Event_Status) ~ lp_mean
)

c_index <- c_index_result$concordance
c_index
```

```{r}
plot(bayes_surv_brms, regex_pars = "b_")

```


```{r}
# predict for a particular machine
target_machine_id <- 42 

# build newdata: one row per (this machine, each component)
target_newdata <- survival_data_final %>%
  filter(machineID == target_machine_id) %>%
  select(
    machineID,
    comp,
    age,
    avg_volt_interval, avg_rotate_interval, avg_pressure_interval, avg_vibration_interval,
    Maint_Count,
    Time_Since_Maint
  ) %>%
  mutate(
    T_End        = 1,
    Event_Status = 1L
  )

# posterior relative risk (exp(linear predictor)) for each component
risk_posterior <- posterior_linpred(
  bayes_surv_brms,
  newdata   = target_newdata,
  transform = TRUE   
)

# posterior mean relative risk per component
Relative_Risk_Score <- apply(risk_posterior, 2, mean)

# build ranking table
risk_ranking <- target_newdata %>%
  mutate(Relative_Risk_Score = Relative_Risk_Score) %>%
  arrange(desc(Relative_Risk_Score))

print(risk_ranking)
```
