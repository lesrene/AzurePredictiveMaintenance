---
title: "maint_BayesianML"
output: html_document
date: "2025-12-03"
---

```{r}
library(dplyr)
library(tidyr)
library(data.table)
library(lubridate)
library(survival)
library(brms)
```

```{r}
errors      <- read.csv("PdM_errors.csv")
failures    <- read.csv("PdM_failures.csv")
machines    <- read.csv("PdM_machines.csv")
maintenance <- read.csv("PdM_maint.csv")
telemetry   <- read.csv("PdM_telemetry.csv")
```

```{r}
errors$count <- 1

error_features <- errors %>%
  group_by(machineID, errorID) %>%
  summarise(count = sum(count), .groups = "drop") %>%
  pivot_wider(
    names_from  = errorID,
    values_from = count,
    values_fill = 0
  )

head(error_features)
```

```{r}
machine_features <- machines %>%
  left_join(error_features, by = "machineID")

# ensure model is treated as a factor
machine_features$model <- as.factor(machine_features$model)

head(machine_features)
```

```{r}
maintenance$total_maint_count <- 1
maintenance$datetime <- as.POSIXct(maintenance$datetime)

# counts of total times each component in each machine got maintained
maint_counts <- maintenance %>%
  group_by(machineID, comp) %>%
  summarise(total_maint_count = sum(total_maint_count), .groups = "drop")
```

```{r}
# recency
CURRENT_DATE <- max(maintenance$datetime)

recency_dates <- maintenance %>%
  group_by(machineID, comp) %>%
  summarise(last_maintenance_date = max(datetime), .groups = "drop") %>%
  mutate(
    how_recent = as.numeric(difftime(CURRENT_DATE, last_maintenance_date, units = "days"))
  )

# final component_features
component_features <- maint_counts %>%
  inner_join(recency_dates %>% select(-last_maintenance_date),
               by = c("machineID", "comp"))

head(component_features)
```

```{r}
component_features_df <- component_features %>%
  rename(
    Maint_Count      = total_maint_count,
    Time_Since_Maint = how_recent
  ) %>%
  left_join(machine_features, by = "machineID")

head(component_features_df)
```


```{r}
# makes sure they are datetime objects
failures$datetime    <- as.POSIXct(failures$datetime)
maintenance$datetime <- as.POSIXct(maintenance$datetime)

# combine failures + maintenance tables
# treat failures as 1 (what we're looking for) and maintenance as 0 (reset the clock)
all_events <- bind_rows(
  failures %>%
    transmute(
      machineID,
      comp = failure,
      datetime,
      Event_Status = 1L   # failure = event
    ),
  maintenance %>%
    transmute(
      machineID,
      comp,
      datetime,
      Event_Status = 0L   # maintenance = censored
    )
) %>%
  arrange(machineID, comp, datetime)
```

```{r}
survival_data_base <- all_events %>%
  group_by(machineID, comp) %>%
  arrange(datetime, .by_group = TRUE) %>%
  mutate(
    start_time = lag(datetime),
    T_End      = as.numeric(difftime(datetime, start_time, units = "hours"))
  ) %>%
  ungroup() %>%
  filter(!is.na(T_End), T_End > 0)

survival_data_base
```

```{r}
telemetry$datetime <- as.POSIXct(telemetry$datetime)
survival_data <- copy(survival_data_base)
setDT(survival_data)
setDT(telemetry)

survival_data_base2 <- telemetry[
  survival_data, 
  on = .(machineID, datetime > start_time, datetime <= datetime)
][,
  .(avg_volt_interval = mean(volt, na.rm = TRUE),
    avg_rotate_interval = mean(rotate, na.rm = TRUE),
    avg_pressure_interval = mean(pressure, na.rm = TRUE),
    avg_vibration_interval = mean(vibration, na.rm = TRUE)),
  by = .(machineID, comp, Event_Status, datetime, T_End)
]
survival_data_base2
```

```{r}
survival_data_final <- survival_data_base2 %>%
  select(-datetime) %>%
  left_join(
    component_features_df,
    by = c("machineID", "comp")
  ) %>%
  mutate(
    Event_Status = as.integer(Event_Status) 
  )
survival_data_final
```
```{r}
glimpse(survival_data_final)
```

```{r}
# Event_Status: 1 = failure (event), 0 = censored
# brms expects censored = 1, event = 0 inside cens()
# so we pass cens(1 - Event_Status)

model_formula_aligned <- bf(
  T_End | cens(1 - Event_Status) ~ 
    age +
    volt + rotate + pressure + vibration +
    Maint_Count +
    Time_Since_Maint
)

set.seed(42)

bayes_surv_brms <- brm(
  formula = model_formula_aligned,
  family  = brmsfamily("cox"),
  data    = survival_data_final,
  prior   = prior(normal(0, 1), class = "b"),
  chains  = 4,
  iter    = 2000,
  cores   = 4
)

summary(bayes_surv_brms)
```


```{r}

plot(bayes_surv_brms, regex_pars = "b_")

```


```{r}
# predict for a particular machine
target_machine_id <- 42 

# build newdata: one row per (this machine, each component)
target_newdata <- component_features_df %>%
  filter(machineID == target_machine_id) %>%
  select(
    machineID,
    comp,
    age,
    volt, rotate, pressure, vibration,
    Maint_Count,
    Time_Since_Maint
  ) %>%
  mutate(
    T_End        = 1,
    Event_Status = 1L
  )

# posterior relative risk (exp(linear predictor)) for each component
risk_posterior <- posterior_linpred(
  bayes_surv_brms,
  newdata   = target_newdata,
  transform = TRUE   
)

# posterior mean relative risk per component
Relative_Risk_Score <- apply(risk_posterior, 2, mean)

# build ranking table
risk_ranking <- target_newdata %>%
  mutate(Relative_Risk_Score = Relative_Risk_Score) %>%
  arrange(desc(Relative_Risk_Score))

print(risk_ranking)
```
